#!/bin/bash -f

#----------------------------------------------------------------------
# Color codes
#----------------------------------------------------------------------
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

#
# Function #1 : mkcd 
#   make directory and cd into it
#
# Usage: mkcd <dir>
function b_mkcd() {
    mkdir -p "$@" && cd "$@"
    printf "Created and changed to directory: %s\n" "$@"
}

#--------------------------------------------------------------------------------
# Function #2 : Git
#--------------------------------------------------------------------------------
#   show git log with pretty format
#
# Usage: gitlog
function b_git_log() {
    git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
}

function b_git_pull() {
    git stash; git pull; git stash pop;
}

#
# b_git_print_*
#
# Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, ...)
# changed (T), are Unmerged (U), are Unknown (X),
#
function b_git_print_added() {
    git diff --cached --name-only --diff-filter=A
}

function b_git_print_modified() {
    git diff --cached --name-only --diff-filter=M
}

function b_git_print_renamed() {
    git diff --cached --name-only --diff-filter=R
}

function b_git_print_deleted() {
    git diff --cached --name-only --diff-filter=D
}


# -----------------------------------------------------------
# Function #3 : License
# -----------------------------------------------------------
function b_checklic() {
    /data/config/env/:lic_checker
}

# -----------------------------------------------------------
# Function #4 : Resources
# -----------------------------------------------------------
# Show system information
function b_sysinfo() {
    echo "=== System Information ==="
    echo "Hostname: $(hostname)"
    echo "Uptime: $(uptime -p)"
    echo "Load Average: $(uptime | awk -F'load average:' '{print $2}')"
    echo "Memory: $(free -h | awk 'NR==2{printf "%.1f%% used (%s/%s)\n", $3*100/$2, $3, $2}')"
    echo "Disk: $(df -h / | awk 'NR==2{printf "%s used (%s available)\n", $5, $4}')"
}

# Show top CPU consuming processes
function b_check_cpu() {
    ps -eo pid,user,%cpu,cmd --sort=-%cpu | head -15
}


# Check DRAM memory usage by processes
function b_check_mem() {
    ps -e -o pid,user,%mem,cmd --sort=-%mem | head -n 10
}

# Check swap memory usage by processes
function b_check_swap() {
    ps -ef | head -n 1
    grep VmSwap /proc/[0-9]*/status \
        | head -n 20 \
        | sort -k2 -nr \
        | awk -F'/' '{ print $3, $4 }' | awk -F' ' '{print $1, $3, $4}' \
        | cut -d: -f1 \
        | while read -r PID SWAP UNIT; do
            echo "=== PID $PID: VmSwap = ${SWAP} ${UNIT} ==="
            ps -ef | grep "[ ]$PID"
            echo
        done
}

#
# b_check_process <process_name>
#   : Count number of running processes per user
# 
# Example: b_check_process tcsh
#
function b_check_process() {
    local proc="$1"
    if [[ -z "$proc" ]]; then
        echo "Usage: b_check_process <process_name>"
        return 1
    fi

    ps -eo user,comm | awk -v p="$proc" '$2==p{count[$1]++} END{for(u in count) print u, count[u]}'
}

# Show open files for your own processes only
function b_check_my_openfiles() {
    local proc="$1"
    if [[ -z "$proc" ]]; then
        echo "Usage: b_check_my_openfiles <process_name>"
        return 1
    fi
    
    # Get PIDs of your own processes first
    local my_pids=$(ps -u $(whoami) -o pid,comm | awk -v p="$proc" '$2==p{print $1}' | tr '\n' ' ')
    
    if [[ -z "$my_pids" ]]; then
        echo "No $proc processes found for user $(whoami)"
        return 1
    fi

    echo "Your '$proc' processes: $my_pids"
    for pid in $my_pids; do
        echo "=== Files for PID $pid ==="
        lsof -p "$pid" 2>/dev/null | grep -E "(REG|DIR)" | head -10
        echo
    done
}

# Show running EDA synthesis/simulation jobs
function b_check_eda_jobs() {
    echo "=== Running EDA Jobs ==="
    echo "--- Synthesis Jobs ---"
    ps aux | grep -E "(dc_shell|icc2_shell|genus)" | grep -v grep
    
    echo "--- Simulation Jobs ---"
    ps aux | grep -E "(vcs|ncsim|vsim|xsim)" | grep -v grep
    
    echo "--- P&R Jobs ---"
    ps aux | grep -E "(innovus|encounter|icc2)" | grep -v grep
    
    echo "--- Verification Jobs ---"
    ps aux | grep -E "(vc_static|spyglass|jaspergold)" | grep -v grep
}

# -----------------------------------------------------------
# Function #5 : Utils
# -----------------------------------------------------------
function b_crlf_to_lf() {
    find . -type f -exec sed -i 's/\r$//' {} +
    echo "Done : CRLF -> LF Change"
}

function b_get_vlog_filelist() {
    xmls -source $1
}

function b_find_files() {
  local OPTIND opt path pattern include_pattern exclude_pattern
  OPTIND=1
  while getopts "d:p:i:e:h" opt; do
    case $opt in
      d) path=$OPTARG ;;
      p) pattern=$OPTARG ;;
      i) include_pattern=$OPTARG ;;
      e) exclude_pattern=$OPTARG ;;
      h) echo "Usage: b_find_files -d <target_dir_path> -p <pattern> [-i <include_pattern>] [-e <exclude_pattern>]"; return ;;
      \?) return 1 ;;
    esac
  done
  # Check
  [[ -z $path || -z $pattern ]] && \
    echo -e "${RED}ERROR${NC}: -d '$path' or -p '$pattern' is empty" && return 1
  # Execute
  find -L "$path" -name "$pattern" \
    | { [[ $include_pattern ]] && grep "$include_pattern" || cat; } \
    | { [[ $exclude_pattern ]] && grep -v "$exclude_pattern" || cat; }
}

# Find files modified in last N days
function b_find_recent_modified_files() {
    local days="${1:-7}"
    find . -type f -mtime -"$days" -exec ls -lt {} + | head -20
}

# Find large files
function b_find_large_files() {
    local size="${1:-100M}"
    find . -type f -size +"$size" -exec ls -lh {} \; | sort -k5 -hr
}

# -----------------------------------------------------------
# Function #6 : symbolic link
# -----------------------------------------------------------
function b_find_symbolic() {
    find . -type l -printf "%p --> %l\n"
}

function b_find_broken_symbolic() {
    find . -type l -exec sh -c 'file -b "$1" | grep -q "^broken"' sh {} \; -print
}

# -----------------------------------------------------------
# Function #7 : source env
# -----------------------------------------------------------
function b_source_pj() {
    source "$(git rev-parse --show-toplevel)/sourceMe.bashrc"
}

# -----------------------------------------------------------
#
# -----------------------------------------------------------